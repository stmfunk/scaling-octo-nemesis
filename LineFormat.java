
import java.io.*;
import java.util.Scanner;
import java.util.ArrayList;

/**
 * An implementation of Line Formatting Algorithms for ADS
 */

public class LineFormat {

    /** `len' is the fixed line length - "L" in the coursework handout. */
    static int len=80;


    /** The method below will implement the dynamic programming 
     * algorithm for the case when we sum the squares of the trailing
     * space, for every line INCLUDING the final one.  The input is a
     * list of integers, representing the lengths of the words in
     * sequence. The output is another (probably shorter) array of
     * integers, describing the position of the line breaks in the
     * optimal formatting.
     * I've commented out the declaration because I was running 
     * tests on the file-handling methods */

    /**  public static int[] dynamicLFall (int[] wordLengths){
     * } */

    /** The method below will exploit the 'dynamicLFall' function
     * to calculate the optimum sequence of line breaks, if our
     * optimisation criterion is instead the sum of squares of all
     * trailing spaces EXCEPT the final one.  The input is a list
     * of integers, representing the lengths of the words in
     * sequence. The output is another (shorter) array of integers,
     * describing the position of the line breaks in the optimal
     * formatting.
     * I've commented out the declaration because I was running 
     * tests on the file-handling methods */

    /**  public static int[] dynamicLFallbutlast (int[] wordLengths){
     * } */


    /** The method below will implement the simple greedy
     * algorithm for computing a line formatting.  We do not 
     * expect the sum-of-squares to be optimal for the outputs
     * of this algorithm.  The input is a list of integers,
     * representing the lengths of the words in sequence. The
     * output is another (shorter) array of
     * integers, describing the position of the line breaks
     * in the greedy formatting. 
     * I've commented out the declaration because I was running 
     * tests on the file-handling methods */

    public static int[] greedyLF (int[] wordLengths){
      int n = wordLengths.length;
      int[] breaks = new int[n];
      int k = 0;
      int buffer = 0;
      for (int i = 0; i < n; i++) {
        if (buffer + wordLengths[i] > len) {
          breaks[k++] = i-1;
          buffer = 0;
        } else {
          buffer += wordLengths[i];
        }
      }
      int[] retBreaks = new int[k];
      for (int i = 0; i < k; i++) {
        retBreaks[i] = breaks[i];
      }
      return retBreaks;
    } 


    public static int[] wordsToLengths(String[] words) {
      int[] wordLengths = new int[words.length];
      for (int i = 0; i < words.length; i++) {
        wordLengths[i] = words[i].length();
      }
      return wordLengths;
    }


    /** You might want to implement the method below, which takes
     * as input (1) a list of word lengths, and (2) a list of indices
     * called breakPoints (describing a chosen line formatting, and
     * probably generated by one of our 3 algorithms), and computes 
     * the ss value of the formatting in terms of sums-of-squares 
     * of trailing whitespace, for all of the lines including the 
     * final one.
     * The method might be useful in the testing stage.  Up to you
     * though.... */

    /**  public int ssAll (int[] wordLengths, int[] breakPoints){
     * } */


    /** You might want to implement the method below, which takes
     * as input (1) a list of word lengths, and (2) a list of indices
     * called breakPoints (describing a chosen line formatting, and
     * probably generated by one of our 3 algorithms), and computes 
     * the ss value of the formatting in terms of sums-of-squares 
     * of trailing whitespaces, for all of the lines except the 
     * last one.
     * The method might be useful in the testing stage.  Up to you
     * though.... */

    /**  public int ssAllbutlast (int[] wordLengths, int[] breakPoints){
     * } */


    /** A method to read the list of words in a given file "fileName"
     * and return these words in order as as list of strings. */

    public static String[] readWordsFile(String fileName) {
	ArrayList<String> list = new ArrayList<String>();
	try {
	    File file = new File(fileName);
	    Scanner scanner = new Scanner(file);
	    while (scanner.hasNext()) {
		list.add(scanner.next());
	    }
	    scanner.close();
	} catch (FileNotFoundException e) {
	    e.printStackTrace();
	}
	return (String[]) list.toArray(new String[1]);
     }

    public static void printWords(String[] words) {
	int i;
	int l = words.length;
	    for (i = 0; i < l; i++) {
		System.out.println(words[i]);
	    }}

    /** The method below is a very simple method to print a list of 
     * words to a file according to a list of breakpoints.  
     * I EXPECT, but don't check, that the breakpoints are in 
     * increasing order, AND that the last entry of the breakPoints 
     * array is equal to words.length.
     * If the last entry of breakPoints array is LESS than the length
     * of the words array, not all words will be printed.   */
    
    public static void printWordsFile(String[] words, int[] breakPoints, 
	String filename) {
	int i,j;
	int l = words.length;
	int b = breakPoints.length;
	FileOutputStream fileout;
	try {
	    fileout = new FileOutputStream(filename);
	    if (b == 0) {
		System.err.println ("Bad input to printWordsFile");
	    } else {
		for (j = 0; (j < l)&&(j < breakPoints[0]-1); j++) {
		    	new PrintStream(fileout).print(words[j]);
			new PrintStream(fileout).print(" ");
		}
		if (breakPoints[0]-1 < l) {
		    new PrintStream(fileout).print(words[breakPoints[0]-1]);
		}
		new PrintStream(fileout).println("");		
		for (i = 1; i < b; i++) {
		    for (j = breakPoints[i-1]; (j < l)&&(j<breakPoints[i]-1); 
			 j++) {
			new PrintStream(fileout).print(words[j]);
			new PrintStream(fileout).print(" ");
		    }
		    if (breakPoints[i]-1 < l) {
			new PrintStream(fileout).print(words[breakPoints[i]-1]);
		    }
		    new PrintStream(fileout).println("");	
		}
	    }
	    fileout.close();
        }
	catch (IOException e) 
	    {			
		System.err.println ("Unable to write to file");
		System.exit(-1);
	    }
    }


	/**
	 * @see java.lang.Object#toString()
	 */
    /**	public String toString() {
     *         StringBuffer buffer = new StringBuffer();
     *          SkipListNode node = head;
     *
     *	while (node.next(0) != tail) {
     *                  node = node.next(0);
     *                  buffer.append(node.getKey() + " ");
     *                  for (int i = 0; i < node.height() + 1; i++) {
     *                           buffer.append("*");
     *                  }
     *                   buffer.append("\n");
     *	    }
     *	return buffer.toString();
     *}
     */

	/*
	 * You should write a main method to run tests on your
	 * Line Formatting methods. 
	 * 
	 * Here I have just written some commands to test the 
	 * file handling little methods I wrote. You can delete 
	 * all these, it's just an example.  -- Mary
	 */



  public static void main(String args[]) {
  	int[] breaks = new int[3];
  	breaks[0]=6;
  	breaks[1]=11;
  	breaks[2]=20;
  	InputStreamReader stdin =
  	    new InputStreamReader(System.in);
  	BufferedReader console =
  	    new BufferedReader(stdin);
          String filename;
  	try {
  		System.out.print("Enter filename: ");
  		filename = console.readLine();	    
  		System.out.println("Thanks for the filename");
  		//printWordsFile(readWordsFile(filename), breaks, "test.out");
  		int[] fish = greedyLF(wordsToLengths(readWordsFile(filename)));
      for (int br = 0; br < fish.length; br++)
        System.out.println(fish[br]);
  		System.exit(0);
  	} catch(IOException ioex) {
  			System.out.println("Input error");
  			System.exit(1);
    }
	}
}
